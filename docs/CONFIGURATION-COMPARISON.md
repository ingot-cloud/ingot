# 配置对比：单服务 vs 微服务多实例共存

> 快速对比单服务独占服务器 vs 微服务多实例共存场景的配置差异

## 📊 场景说明

### 场景 A：单服务独占（不推荐）
- 服务器：8C16G
- 部署：单个 PMS 服务
- 特点：资源充足，可配置较高

### 场景 B：微服务多实例共存（实际场景）⭐
- 服务器：8C16G
- 部署：Gateway + Auth + PMS + Member + MySQL + Redis
- 特点：资源需合理分配，避免争抢

---

## 🔧 核心配置对比

### 1. JVM 内存配置

| 配置项 | 场景 A（单服务） | 场景 B（多服务）⭐ | 说明 |
|--------|-----------------|-------------------|------|
| **-Xms** | 6g | **2g** | 初始堆内存 |
| **-Xmx** | 6g | **2g** | 最大堆内存 |
| **MetaspaceSize** | 256m | 256m | 元空间初始大小 |
| **MaxMetaspaceSize** | 512m | **384m** | 元空间最大大小 |
| **MaxDirectMemorySize** | 1g | **256m** | 堆外内存限制 |

**场景 B 计算依据**：
```
8C16G 总内存 = 16G
- 系统预留：2G
- Gateway：2.5G（JVM 2G + 其他 0.5G）
- Auth：   2.5G
- PMS：    2.5G
- Member： 2.5G
- MySQL：  1G
- Redis：  512M
- 缓冲：   512M
--------------
总计：    14G（符合）
```

---

### 2. 数据库连接池配置

| 配置项 | 场景 A | 场景 B ⭐ | 说明 |
|--------|--------|----------|------|
| **initial-size** | 20 | **10** | 初始连接数 |
| **min-idle** | 20 | **10** | 最小空闲连接 |
| **max-active** | 100 | **50** | 最大活跃连接 |
| **max-wait** | 5000ms | 5000ms | 最大等待时间 |

**场景 B 连接数规划**：
```
MySQL max_connections = 500

连接分配：
- Auth:    50
- PMS:     50
- Member:  50
- 其他:    50
-----------
总计:     200（预留 300）
```

---

### 3. Web 容器线程池配置

| 配置项 | 场景 A | 场景 B ⭐ | 说明 |
|--------|--------|----------|------|
| **undertow.io** | 8 | **4** | IO 线程数 |
| **undertow.worker** | 256 | **120** | 工作线程数 |

**场景 B 线程数计算**：
```
8 核 CPU

线程分配（每服务）：
- Gateway: io=4, worker=200
- Auth:    io=4, worker=150
- PMS:     io=4, worker=120
- Member:  io=4, worker=120

总计：worker ≈ 590（CPU 可超额分配）
```

---

### 4. 异步任务线程池配置

| 配置项 | 场景 A | 场景 B ⭐ | 说明 |
|--------|--------|----------|------|
| **core-size** | 20 | **10** | 核心线程数 |
| **max-size** | 100 | **50** | 最大线程数 |
| **queue-capacity** | 500 | **200** | 队列容量 |

---

### 5. Redis 连接池配置

| 配置项 | 场景 A | 场景 B ⭐ | 说明 |
|--------|--------|----------|------|
| **max-active** | 50 | **30** | 最大活跃连接 |
| **max-idle** | 20 | **15** | 最大空闲连接 |
| **min-idle** | 10 | **5** | 最小空闲连接 |

---

### 6. 网关限流配置

| 配置项 | 场景 A | 场景 B ⭐ | 说明 |
|--------|--------|----------|------|
| **replenishRate** | 500 | **300** | 每秒放入令牌数 |
| **burstCapacity** | 1000 | **500** | 令牌桶容量 |
| **max-connections** | 1000 | **500** | HTTP 客户端最大连接 |

---

### 7. Docker 资源限制

#### 场景 A：单服务
```yaml
pms:
  mem_limit: 8g        # 可用更多内存
  cpus: '4.0'          # 可用更多 CPU
```

#### 场景 B：多服务 ⭐
```yaml
gateway:
  mem_limit: 2560m
  mem_reservation: 2g
  cpus: '2.0'

auth:
  mem_limit: 2560m
  mem_reservation: 2g
  cpus: '2.0'

pms:
  mem_limit: 2560m
  mem_reservation: 2g
  cpus: '1.5'

member:
  mem_limit: 2560m
  mem_reservation: 2g
  cpus: '1.5'
```

---

## 📈 性能对比

### QPS 能力

| 场景 | 单服务 QPS | 说明 |
|------|-----------|------|
| **场景 A** | 1000-3000 | 单个服务独占资源 |
| **场景 B** | 300-500 | 每个服务，多服务共存 |

**场景 B 整机能力**：
```
假设 4 个服务均衡分配请求：
总 QPS ≈ 400-600 QPS

注意：实际受限于最慢的服务（通常是认证服务）
```

### 响应时间

| 场景 | P50 | P95 | P99 |
|------|-----|-----|-----|
| **场景 A** | 50ms | 200ms | 500ms |
| **场景 B** | 80ms | 300ms | 800ms |

场景 B 响应时间略高，因为：
- 资源竞争
- 上下文切换
- GC 影响

---

## 🎯 1000 用户场景部署方案

### 场景 A：单服务独占（不现实）
```
需要 1 台服务器 × 4 个服务 = 4 台
- 服务器 1：PMS
- 服务器 2：Auth
- 服务器 3：Member
- 服务器 4：Gateway

成本：4 × 8C16G = 32C64G
```

### 场景 B：微服务多实例共存（推荐）⭐
```
需要 2 台应用服务器 + 1 台数据库服务器
- 应用服务器 1/2：Gateway + Auth + PMS + Member（各 2G）
- 数据库服务器：MySQL + Redis

成本：2 × 8C16G + 1 × 4C8G = 20C40G
节省：37.5%
```

---

## ⚖️ 配置决策树

```
开始
  │
  ├─ 是否单服务独占服务器？
  │   ├─ 是 → 使用场景 A 配置（高资源配置）
  │   │       - JVM: 6G
  │   │       - 连接池: 100
  │   │       - 线程: 256
  │   │
  │   └─ 否 → 是否微服务多实例？
  │       └─ 是 → 使用场景 B 配置（适度配置）⭐
  │               - JVM: 2G
  │               - 连接池: 50
  │               - 线程: 120
  │               - 考虑服务数量和资源总量
  │
  └─ 部署后监控并调整
      - CPU < 70%
      - 内存 < 80%
      - 响应时间 < 500ms (P95)
```

---

## 🔍 如何选择配置

### 问自己 3 个问题：

#### 1. 服务器上运行几个服务？
- **1 个服务** → 场景 A（高配置）
- **2-4 个服务** → 场景 B（适度配置）
- **5+ 个服务** → 需要更保守的配置

#### 2. 服务器内存有多少？
```
总内存 ÷ (服务数量 + 2) = 单服务可用内存

示例：16G ÷ (4 + 2) ≈ 2.6G
→ 单服务 JVM 配置 2G（预留 0.6G 给容器开销）
```

#### 3. 数据库最大连接数是多少？
```
MySQL max_connections ÷ 服务数量 = 单服务可用连接数

示例：500 ÷ 4 ≈ 125
→ 考虑预留，单服务配置 50-80 个连接
```

---

## 📋 配置检查清单

### 部署前检查（场景 B：多服务）

- [ ] **内存规划**
  - [ ] 所有服务内存之和 < 总内存 × 0.9
  - [ ] 单服务 JVM 堆内存 < 容器限制 × 0.8
  - [ ] 预留 2G 系统内存

- [ ] **连接池规划**
  - [ ] 所有服务连接数之和 < MySQL max_connections × 0.6
  - [ ] 单服务 max-active 设置合理（通常 50-80）
  - [ ] Redis 连接数控制在 30 以内

- [ ] **线程池规划**
  - [ ] IO 线程 = 4（不超过 CPU 核心数）
  - [ ] Worker 线程 = 100-150（根据业务调整）
  - [ ] 所有服务线程数之和适度（可超额）

- [ ] **限流配置**
  - [ ] 网关限流 ≤ 后端总能力
  - [ ] 单服务限流 = 网关限流 ÷ 服务数量

- [ ] **Docker 资源限制**
  - [ ] 设置 mem_limit 和 cpus 限制
  - [ ] 避免某个服务占用过多资源

### 部署后监控

- [ ] CPU 使用率 < 70%（所有服务总和）
- [ ] 内存使用率 < 80%（所有服务总和）
- [ ] 数据库连接数 < max_connections × 0.8
- [ ] 响应时间 P95 < 500ms
- [ ] 错误率 < 0.1%

---

## 🛠️ 快速调整命令

### 查看当前资源使用
```bash
# 查看所有服务资源
docker stats

# 查看内存详情
docker stats --format "table {{.Name}}\t{{.MemUsage}}\t{{.MemPerc}}"

# 查看 CPU 详情
docker stats --format "table {{.Name}}\t{{.CPUPerc}}"
```

### 临时调整资源
```bash
# 增加内存限制
docker update --memory=3g ingot-pms

# 增加 CPU 限制
docker update --cpus=2.0 ingot-pms

# 重启服务应用新的环境变量
docker restart ingot-pms
```

### 监控数据库连接
```bash
# 查看 MySQL 连接数
docker exec -it mysql mysql -uroot -p -e "SHOW STATUS LIKE 'Threads_connected';"

# 查看连接详情
docker exec -it mysql mysql -uroot -p -e "SHOW PROCESSLIST;"
```

---

## 📚 相关文档

- **[微服务资源规划指南](./MICROSERVICES-RESOURCE-PLANNING.md)** - 详细的资源规划
- [故障排查指南](./TROUBLESHOOTING-SERVICE-HANG.md) - 问题排查
- [配置示例](./config-examples/README.md) - 具体配置文件
- [快速参考](./QUICK-REFERENCE-TROUBLESHOOTING.md) - 快速查阅

---

## 💡 总结

| 方面 | 场景 A（单服务） | 场景 B（多服务）⭐ |
|------|-----------------|-------------------|
| **适用场景** | 单体应用，资源充足 | 微服务架构，资源共享 |
| **JVM 内存** | 6G | 2G |
| **连接池** | 100 | 50 |
| **线程池** | 256 | 120 |
| **单服务 QPS** | 1000-3000 | 300-500 |
| **整机 QPS** | 1000-3000 | 400-600 |
| **资源利用率** | 低（1 服务占用全部）| 高（4 服务合理分配）|
| **成本** | 高（需要多台服务器）| 低（服务器利用率高）|

**推荐使用场景 B 配置**：更符合实际微服务部署场景，资源利用率高，成本低。

---

**最后更新**：2025-12-24  
**版本**：v1.0  
**建议**：根据实际监控数据动态调整配置

